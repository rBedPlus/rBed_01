# bgmc_matching.R  
# Author: Eason Li
# Date: 12/15/2021

all_tests_matching = function()
{ 
  # cut and paste into the R-shell any group of these commands
  source("~/__init_rBed_01.R")
  rBedPath = glob[["rBedPath"]]  
  glob[["workDir"]] = paste0(rBedPath, "/rBed_bgmc", "/bgmc_matching", "/workDir") 
  setwd(glob[["workDir"]])
  
  instanceDirs = "../../../_data_tiny/bigraph/unate/"
  fg_bgmc_matching_experiment_R(instanceDirs, id="matrixF")
  
  instanceDef = "../../../_data_tiny/bigraph/unate/ruler_9_22.cnfU"
  fg_bgmc_matching_plot(instanceDef)
  
  javaRDS = "fg_bgmc_matching_experiment_java_56_dt.RDS"
  rRDS = "fg_bgmc_matching_experiment_R_56_dt.RDS"
  fg_bgmc_matching_experiments_plot(javaRDS, rRDS)
  
  # convert txt to RDS
  dt = fread("../../../_data/bigraph/unate/total/all.txt")
  dt$runtime_read = round(dt$runtime_read / 1000, 3)
  dt$runtime = round(dt$runtime / 1000, 3)
  fileRDS         = "fg_bgmc_matching_experiment_java_59_dt.RDS"
  saveRDS(dt     , fileRDS)
  cat(sep="",
      "------------------------------------------------",
      "\n   print(readRDS(\"", fileRDS, "\"))",
      "\n\n")
  
} # all_tests_matching

fg_bgmc_matching_experiment_R = function(instanceDirs, id="matrixF") {  
  
  # Main function for doing experiment. Takes a instance directory as input
  # id can be "matrixF" - full matrix, or "matrixS" - sparse matrix
  # sparse matrix can be faster for reading files
  thisFunction = "fg_bgmc_matching_experiment_R"
  cat("\n.. entering", thisFunction, " on", date(), "\n")
  
  # find required files form for specified instanceDir
  filePaths = c()
  for (instanceDir in instanceDirs) {
    files = list.files(instanceDir)
    for (file in files) {
      fileExts = c("cnf", "cnfU", "cnfW")
      if (file_ext(file) %in% fileExts) {
        filePaths = c(filePaths, file.path(instanceDir, file))
      }
    }
  }
  
  
  matrix_id = id
  i = 1
  dt = data.table()
  for (instanceDef in filePaths) {
    if (i == 10) {break}
    i = i + 1
    # read the instance
    start_time = Sys.time() 
    read_bgu(instanceDef, matrix_id)  
    instanceName = basename(instanceDef)
    nCols        = glob[["nCols"]]
    mRows        = glob[["mRows"]]
    M            = glob[["matrixF"]]
    end_time = Sys.time() 
    runtime_read  = round(as.numeric(end_time - start_time), 3)
    
    # need a transpose of M to generate the graph 
    start_time = Sys.time() 
    G = graph_from_incidence_matrix(t(M) ) 
    answ = max_bipartite_match(G)
    matching_size = answ$matching_size
    end_time = Sys.time()
    runtime_match  = round(as.numeric(end_time - start_time), 3)
    
    dt = rbind(dt, data.table(
      instanceDef  = basename(instanceDef),
      matrix_id = matrix_id,
      matching_size = matching_size,
      runtime_read = runtime_read,
      runtime_match = runtime_match)     
    )
    cat(".. solved", basename(instanceDef), 
        "runtime_read =", runtime_read,
        "runtime_match =", runtime_match,
        "\n")
  }
  
  num_of_instances = length(filePaths)
  dtPairs = data.table(
    thisFunction       = thisFunction,
    userId             = Sys.info()[["user"]], 
    cpuName            = Sys.info()[["nodename"]], 
    sysName            = Sys.info()[["sysname"]],
    dateStamp          = Sys.Date(),
    timeStamp          = format(Sys.time(), "%X"),
    "---- " = "",
    num_of_instances = num_of_instances,
    matrix_id  = matrix_id)
  
  fileRDS_dt      = paste(thisFunction,  "_", num_of_instances, "_dt.RDS", sep="")
  fileRDS_dtPairs = paste(thisFunction,  "_", num_of_instances, "_dtPairs.RDS", sep="")
  saveRDS(dt     , fileRDS_dt)
  saveRDS(dtPairs, fileRDS_dtPairs)  
  cat(sep="",
      "------------------------------------------------",
      "\n** saved datatables generated by function ", thisFunction, " in files",
      "\n   ", fileRDS_dtPairs,
      "\n   ", fileRDS_dt, 
      "\n Access any file either as",
      "\n   print(readRDS(\"", fileRDS_dtPairs, "\"))",
      "\n   print(readRDS(\"", fileRDS_dt, "\"))",
      "\n or as",
      "\n   dtP = readRDS(\"", fileRDS_dtPairs, "\")",
      "\n   dtE = readRDS(\"", fileRDS_dt, "\")",
      "\n\n")
  
  print(t(dtPairs))
  cat("\n.. completed", thisFunction, " on", date(), "\n")
  
} # fg_bgmc_matching_experiment_R

fg_bgmc_matching_experiments_plot = function(javaRDS, rRDS) {
  
  # function for plotting the experiments between Java and R results
  thisFunction = "fg_bgmc_matching_experiments_plot"
  
  dtJava = readRDS(javaRDS)
  colnames(dtJava) = c("instanceDef", "runtime_read", "runtime_match",
                       "matching_size")
  dtJava$matrix_id = "matrixF"
  dtJava$type = "Java"
  dtJava = dtJava[order(instanceDef)]
  dtJava$instanceIndex = seq(nrow(dtJava))
  
  dtR    = readRDS(rRDS)
  colnames(dtR) = c("instanceDef", "matrix_id", "matching_size",
                       "runtime_read", "runtime_match")
  dtR$type = "R"
  dtR = dtR[order(instanceDef)]
  dtR$instanceIndex = seq(nrow(dtR))
  
  dtExp = rbind(dtJava,dtR)
  
  print(dtExp, nrow=112)
  
  
  # dtIndex_read = unique(dtExp[runtime_read > 0.1]$instanceIndex)
  # 
  # dt = dtExp[instanceIndex %in% dtIndex_read,]
  
  
  dtIndex_read = unique(dtExp[runtime_read > 0.4]$instanceIndex)
  dtIndex_orlib = dtExp[instanceDef %in% c("scpb1.cnfU","scpc1.cnfU",
                                           "scpd1.cnfU", "steiner3_243_9801.cnfU",
                                           "steiner3_135_3015.cnfU")]$instanceIndex
  
  
  dtIndex_read = c(dtIndex_read, dtIndex_orlib)
  dt = dtExp[instanceIndex %in% dtIndex_read,]
  # 
  # dt = dtExp
  dt$instanceIndex = rep(seq(nrow(dt)/2),2)
  
  # dt$instanceDef = sub("W$", "U", dt$instanceDef)
  
  sp_tb = dt[,c("instanceIndex", "instanceDef")]
  sp_tb = unique(sp_tb)
  # sp2_tb = tail(dtExp[,c("instanceIndex", "instance")], 17)
  
  p1 = ggplot(dt, aes(instanceIndex, runtime_read, fill=type)) +
    geom_bar(stat = "identity", position = 'dodge') +
    scale_x_continuous(labels = as.character(seq(nrow(dt)/2)), breaks = seq(nrow(dt)/2)) +
    annotation_custom(tableGrob(sp_tb,rows = NULL,theme = ttheme_default(base_size = 8))) +
    theme(legend.position = c(0.1, 0.4), legend.key.size = unit(.3, 'inch'),
          legend.text = element_text(size=15),
          legend.title = element_blank())
  
  p2 = ggplot(dt, aes(instanceIndex, runtime_match, fill=type)) +
    geom_bar(stat = "identity", position = 'dodge') +
    scale_x_continuous(labels = as.character(seq(nrow(dt)/2)), breaks = seq(nrow(dt)/2)) +
    annotation_custom(tableGrob(sp_tb,rows = NULL,theme = ttheme_default(base_size = 8))) +
    theme(legend.position = c(0.1, 0.4), legend.key.size = unit(.3, 'inch'),
          legend.text = element_text(size=15),
          legend.title = element_blank())
  
  space=paste(rep(" ", 180), collapse = "")
  p = grid.arrange(p1, p2, nrow=1,
                    top = textGrob(paste("fg_bgmc_matching_read",space ,
                                         "fg_bgmc_matching_match"),
                                   x = 0.04, y = 0, hjust = 0,
                                   gp=gpar(fontsize=8,font=1, col="gray47")))
  
  
  ggsave("fg_bgmc_matching_experiment.pdf", p, width = 14, height = 5)
  
  
} # fg_bgmc_matching_experiments_plot

fg_bgmc_matching_plot = function(instanceDef) {
  # plot a single instance
  thisFunction = "fg_bgmc_matching_plot"
  
  # read the instance
  read_bgu(instanceDef, id="matrixF") ;# print(glob) ; return()
  
  instanceName = basename(instanceDef)
  nCols        = glob[["nCols"]]
  mRows        = glob[["mRows"]]
  M            = glob[["matrixF"]]
  
  # find degree of each column vertex 
  
  # find numEdges
  colDegs = c()
  for (j in 1:nCols) { colDegs[j] = sum(M[,j]) }
  edgesFromCols = sum(colDegs)
  colDegsMin      = min(colDegs)
  colDegsMedian   = median(colDegs) 
  colDegsMean     = round(mean(colDegs), 4)
  colDegsStdev    = round(sd(colDegs), 4)
  colDegsMax      = max(colDegs)
  colDegs        = paste(sort(colDegs), collapse=",")
  
  # find degree of each row vertex 
  rowDegs = c()
  for (i in 1:mRows)  { rowDegs[i] = sum(M[i,]) }
  edgesFromRows = sum(rowDegs)
  rowDegsMin      = min(rowDegs) 
  rowDegsMedian   = median(rowDegs) 
  rowDegsMean     = round(mean(rowDegs), 4)
  rowDegsStdev    = round(sd(rowDegs), 4)
  rowDegsMax      = max(rowDegs)  
  rowDegs        = paste(sort(rowDegs), collapse=",")
  
  tempM = t(M)
  rownames(tempM) = paste("p", seq(nrow(tempM)), sep = "")
  colnames(tempM) = paste("t", seq(ncol(tempM)), sep = "")
  
  
  G    = graph_from_incidence_matrix( tempM )  ;# need a transpose here  
  
  answ = max_bipartite_match(G) ;# print(answ)
  matching_size = answ$matching_size
  matching      = answ$matching 
  
  
  
  cat("\n.. edgeList \n")    
  edges <- ends(G, es=E(G), names=F) ; print(edges)
  
  V(G)$name = c(rownames(tempM), colnames(tempM))
  V(G)$color = 'cadetblue1'
  V(G)[type]$color = 'antiquewhite'
  V(G)$label.cex <- .5
  V(G)$size <- 12
  E(G)$color = "gray"
  
  match_name = names(answ$matching)
  match_value = unname(answ$matching)
  
  for (i in 1:length(match_name)) {
    if (is.na(match_value[i])) {
      next
    }
    path = c(match_name[i], match_value[i])
    # E(G, path=path)$color <- "red"
  }
  plot(G, layout = layout_as_bipartite)
  
  dtPairs = data.table(
    thisFunction = thisFunction,
    date       = date(),
    instanceDef = basename(instanceDef),
    nCols = nCols,
    mRows    = mRows,
    numEdges   = answ$matching_size,
    matrixDens = glob[["matrixDens"]], 
    " " = "",
    colDegsMin    = colDegsMin,
    colDegsMedian = colDegsMedian,
    colDegsMean   = colDegsMean,
    colDegsStdev  = colDegsStdev,
    colDegsMax    = colDegsMax,
    " " = "",
    rowDegsMin    = rowDegsMin,
    rowDegsMedian = rowDegsMedian,
    rowDegsMean   = rowDegsMean,
    rowDegsStdev  = rowDegsStdev,
    rowDegsMax    = rowDegsMax,
    colDegs = colDegs,
    rowDegs = rowDegs,
    matchingMax = matching_size,
    matchingEdges = matching
  )
  print(t(dtPairs)) 
  
  cat(".. plotted a bipartite graph with package 'igraph'\n")
  return(paste(".. returning from function", thisFunction))
  
} # fg_bgmc_matching_plot


